# クラスとインタフェース

## 項目15 クラスとメンバーへのアクセス可能性を最小限にする

良い設計のコンポーネントとは？

- → その実装の詳細をすべて隠蔽し、実装と API をはっきりと分離している
- → 情報隠蔽（information hiding）、カプセル化（incapsulation）

情報隠蔽をすることで、システムを構成するコンポーネントを効果的に分離し、個別かつ並行して開発、テスト、最適化、利用、理解、修正することができる

各クラスをできる限りアクセスできないようにするべき

### トップレベルのクラスやインタフェースに指定できるアクセスレベル

- package-private（デフォルト）
- public

トップレベルの package-private のクラスまたはインタフェースが一つのクラスだけで使われているなら、その使用しているクラス内にネストされた private のクラスにすることを検討する（項目24）。

### フィールド、メソッド、ネストしたクラスやインタフェースに指定できるアクセスレベル

- private … これが宣言されたトップレベルのクラス内でのみアクセス可
- package-private（インタフェースのメンバー以外のデフォルト） … これが宣言されたパッケージ内のどのクラスからでもアクセス可
- protected … pakcage-private + これが宣言されたクラスのサブクラス
- public（インタフェースのメンバーのデフォルト） … どこからでもアクセス可

### とりあえず private にする

クラスの public な API をちゃんと設計したら、とりあえず他の全てのメンバーを private にする。パッケージ内の他クラスからのアクセスが必要な場合だけ private を外す（package-private になる）。頻繁に private を外しているなら、もっとうまく分離できないか設計を見直す。

とはいえ、private と package-private はどちらもクラスの公開 API に影響を与えない。しかし、クラスが Serializable（項目86, 項目87）を実装していれば、private や package-private なフィールドでも公開 API に漏洩してしまう。

### protected の扱いには要注意

public クラスのメンバーが package-private から protected に変更された場合、大幅にアクセス可能性が増大する。protected はあまり使いすぎないほうが良い。

### オーバーライド時のアクセスレベル

スーパークラスのメソッドをオーバーライドする場合、元のメソッドよりも低いアクセス権を設定することはできない（コンパイルエラーになる）。これは、リスコフの置換原則（項目10 参照）を満たす必要があるため。
また、インタフェースを実装する場合、そのクラスのメンバーは全て public として実装しなければならない。

### テストのためにアクセスレベルを緩めたいとき

テストのために public クラスの private メソッドを package-private にするのは OK。

それ以上緩めるのは NG。テストのために公開 API の一部となるのはダメ。  
パッケージ内にテストを書けば package-private の要素にアクセスできるので、その必要はない。

### インスタンスフィールドは public にすべきではない (項目16)

final ではないインスタンスフィールドや可変オブジェクトへの参照であるインスタンスフィールドを public にした場合、そのフィールドに保存できる値を制限できなくなる。つまり、そのフィールドに関係する不変式の強制（？）やフィールドが変更されたときに何らかの処理を行うことができなくなる。このような理由から、public の可変フィールドを持つクラスは一般的にスレッドセーフでない。

また、不変オブジェクトを参照している final のフィールドを public にする場合、そのフィールドを今とは違う表現へ変更することが難しくなる。

### static フィールドも public にすべきではない。ただし、定数フィールドは可

static フィールドも同様に public にすべきではないが、定数は例外的に public static final にできる。これは、定数がクラスが提供する抽象化の不可欠な部分を構成するという仮定があるためである。定数フィールドは大文字で単語間をアンダースコアで区切った名前が付けられる(項目68)。

定数フィールドは基本データ型の値か不変オブジェクトへの参照のどちらかしか持たないようにする。変更可能オブジェクトへの参照を持つ final のフィールドは、その参照自体を変更することはできないが参照先のオブジェクトを変更できるため、final でないフィールドの欠点を全て持っている。

長さがゼロではない配列の内容は常に変更可能なので、クラスが public static final の配列フィールドやそのようなフィールドを返すアクセッサーを持つのは誤りである。

例えば、次のコードはセキュリティホールを持っている。

```
public static final Thing[] VALUES = {...};
```

これを解決する方法は2つある。どちらを使うかは「どちらの戻り値が便利か」「どちらのパフォーマンスが良いか」によって決める。

#### 解決法1: 配列を private にして、public の変更不可能なリストを作る

```
private static final Thing[] PRIVATE_VALUES = {...};
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```

#### 解決法2: 配列を private にして、そのコピーを返す public メソッドを作る

```
private static final Thing[] PRIVATE_VALUES = {...};
public static final Thing[] values() {
    return PRIVATE_VALUES.clone();
}
```

### module のアクセスレベル

- パッケージ … クラスのグループ化
- モジュール … パッケージのグループ化

モジュールは、モジュール宣言内のエクスポート宣言によって一部のパッケージを明示的に公開する。

- エクスポートされたパッケージ … モジュール外から public や protected のメンバーにアクセスできる
- エクスポートされていないパッケージ … モジュール外から public や protected のメンバーにアクセスできない

ただし、モジュールに基づくアクセスレベルは勧告的なものである。例えば、モジュールの JAR ファイルをアプリケーションのモジュールパスではなくクラスパスに配置すると、モジュール内のパッケージはモジュールに対応していない振る舞いになる。

唯一 JDK 自身が持つ Java ライブラリにおけるモジュールのアクセスレベルは厳格に強制される。

以上のような理由から、JDK 自身以外でモジュールが広く使われていくかはわからないため、やむを得ない必要がない限りはモジュールを使うのは避けたほうが良い。

### まとめ

- 常にプログラムの要素のアクセス可能性をできる限り（理にかなった範囲で）低減させるべき
- 最低限の public の API を注意深く設計した後は、関係のないクラス、インタフェース、メンバーがその API の一部となるのを防ぐべき
- 定数としての役割を果たす public static final のフィールドの例外はあるが、public のクラスは public のフィールドを持つべきではない
- public static final のフィールドで参照されているオブジェクトが変更不可であるようにする

## 項目16 public のクラスでは、public のフィールドではなく、アクセッサーメソッドを使う

```
class Point {
    public double x;
    public double y;
}
```

このようなクラスのデータフィールドは直接アクセスされるので、カプセル化できていない。具体的には、

- API を変更せずに、その表現形式を変更できない
- 不変式を強制できない
- フィールドが変更されたときに何らかの補助処理ができない

という問題がある。

### アクセッサーメソッドとミューテーターを使う

フィールドを private 化し、アクセッサーメソッド（ゲッター）とミューテーター（セッター）を追加する。

```
class Point {
    private double x;
    private double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() { return x; }
    public double getY() { return y; }

    public void setX(double x) { this.x = x; }
    public void setY(double y) { this.y = y; }
}
```

### アクセッサーメソッドとミューテーターを使う必要がない場合

クラスがパッケージの外からアクセスされない package-private や private のネストしたクラスである場合、データフィールドを直接公開することは問題ではない。（むしろ、クラス定義及びクラスを使っている場所の両方で見やすいコードになる。）

Java プラットフォームライブラリのクラスによっては、public のクラスはフィールドを直接公開しているものがある。例えば、 java.awt パッケージ内の Point クラスと Dimension クラスはフィールドを直接公開している。これは、真似すべき例ではない。項目67で説明されているように、Dimension クラスの内部を公開すると決めたことで、今日も存在する重大なパフォーマンス問題を生み出した。

### 不変フィールドを直接公開する

public クラスのフィールドを直接公開するのは良くないが、不変フィールドであれば害は少ない。

## 項目17 可変性を最小限にする

不変クラスとは、個々のインスタンスに保持される情報の全てがオブジェクトの生存期間中において変化しないクラスである。

Java プラットフォームライブラリには String、ボクシングされた基本データクラス、BigInteger、BigDecimal 等、多くの不変クラスがある。これは、不変クラスの設計、実装、使用が可変クラスよりも容易で、誤りにくく安全であるためである。

### 不変クラスを作るための規則

#### 1. オブジェクトの状態を変更するためのメソッドを提供しない

そのまま。

#### 2. クラスを拡張できないようにする

サブクラスが、オブジェクトの状態が変更されたかのように振る舞うことを防ぐ。

サブクラス化を防ぐには一般にクラスを final とするが、後で紹介する別の方法もある。

#### 3. すべてのフィールドを final にする

もし新たに生成されたインスタンスへの参照が一つのスレッドから他のスレッドへ同期なしで渡されるなら、メモリモデルで説明されているように、正しい振る舞いを保証する必要がある。

#### 4. すべてのフィールドを private にする

クライアントがフィールドから参照されている可変オブジェクトへアクセスして、そのオブジェクトを直接変更することを防ぐ。

不変クラスが public final フィールドを持つことは技術的に問題ないが、その後のリリースで内部表現を変更できなくなるので推奨されない（項目15、項目16）。

#### 5. 可変コンポーネントに対する独占的アクセスを保証する

クラスが可変オブジェクトを参照するフィールドを持っているなら、クライアントがそれらのオブジェクトへの参照を取得できないようにする必要がある。コンストラクタ、アクセッサー、readObject メソッド（項目88）で防御的コピー（項目50）をする。

### 関数的方法を用いる

```
public final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public double realPart() { return re; }
    public double imaginaryPart() { return im; }

    public Complex plus(Complex c) {
        return new Complex(re + c.re, im + c.im);
    }

    public Complex minus(Complex c) {
        return new Complex(re - c.re, im - c.im);
    }

    public Complex times(Complex c) {
        return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);
    }

    public Complex dividedBy(Complex c) {
        double tmp = c.re * c.re + c.im * c.im;
        return new Complex((re * c.re + im * c.im) / tmp, (im * c.re - re * c.im) / tmp);
    }

    @Override public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof Complex))
            return false;
        Complex c = (Complex) o;

        // == の代わりに compare を使う理由については49ページを参照
        return Double.compare(c.re, re) == 0 && Double.compare(c.im, im) == 0;
    }

    @Override public int hashCode() {
        return 31 * Double.hashCode(re) + Double.hashCode(im);
    }

    @Override public String toString() {
        return "(" + re + " + " + im + "i)";
    }
}
```

上の Complex クラスでは、算術操作がインスタンスを変更するのではなく、関数的方法を用いて新たな Complex インスタンスを生成して返している。一般的な手続き的または命令的方法と比較すると、add のような動詞ではなく plus のような前置詞がメソッド名に使われており、これによってメソッドがオブジェクトの値を変更しないことを強調している。BigInteger クラスと BigDecimal クラスはこの命名規約に従っておらず、多くの誤用を引き起こした。

### 不変オブジェクトの共有

可変オブジェクトが任意の複雑な状態空間を持つ一方で、不変オブジェクトは必ず作られたときの状態を維持するので単純である。また、不変オブジェクトは本質的にスレッドセーフなので、同期を必要としない。これにより、不変クラスは制限なく共有することができる。

#### 定数として共有する

例えば、Complex クラスは頻繁に使われる値を次のように定数として提供することができる。

```
public static final Complex ZERO = new Complex(0, 0);
public static final Complex ONE = new Complex(1, 0);
public static final Complex I = new Complex(0, 1);
```

#### キャッシュして共有する

さらに発展して、既存のインスタンスを再利用できる場合に新たなインスタンスを避けるため、頻繁に利用されるインスタンスをキャッシュする static ファクトリメソッドを提供することもできる（項目1）。全てのボクシングされた基本データクラスと BigInteger は、このような static ファクトリメソッドを持っている。新たにクラスを設計する際に public のコンストラクタの代わりに static ファクトリメソッドを選択することで、クライアントを修正せずに後でキャッシュを追加する柔軟性を持たせられる。

不変オブジェクトは制限なく共有できるため、防御的コピー（項目50）を行う必要がない。コピーはもとのインスタンスと永久に同値なのでコピーを行う必要はない。よって、不変クラスに対して clone メソッドやコピーコンストラクタ（項目13）を提供する必要はないし、提供すべきではない。Java プラットフォームの初期にはこのことが十分に理解されていなかったため String クラスはコピーコンストラクタを持っているが、めったに使用されるべきではない（項目6）。

#### 内部を共有する

不変オブジェクトはそれ自体を共有できるだけでなく、その内部も共有できる。

例えば、BigInteger クラスでは内部的に「符号 - 大きさ」を使っており、符号は int、大きさは int 配列で表現されている。negate メソッドは同じ大きさで符号を反転させた新たな BigInteger を生成する。この際、negate メソッドは大きさを表す int 配列をコピーする必要がない。

### 不変オブジェクトの利点

- 他のオブジェクトに対する素晴らしい構成要素を作り出す（？）
- 追加コストなしでエラーアトミック性を提供する（項目76）

### 不変クラスの欠点

不変クラスの唯一の欠点は、個々のオブジェクトを必要とすることである。

例えば、100万ビットから成る BigInteger があるとして、その最下位ビットを反転させる場合、flipBit メソッドはもとのインスタンスとたった1ビットしか違わない100万ビット長の新たな BigInteger インスタンスを生成する。この操作にはその大きさに比例した時間と空間が必要になる。

一方、可変クラスである java.util.BigSet は BigInteger と同様に任意長のビット列を表現しているが、一定時間で100万ビット中の1ビットの状態を変更することができる。

複数ステップの操作を行う際、各ステップで新たなオブジェクトを生成し、最終的に最後の結果以外のオブジェクトを破棄する場合、パフォーマンスの問題は大きくなる。

#### 解決策1: 複数ステップの操作をまとめる

どのような複数ステップの操作が一般的に要求されるかを推測して、それをまとめたメソッドを提供することでパフォーマンスを改善できる。これは、クライアントがどのような操作を行いたいかを正確に予想できればうまくいく。

例えば、BigInteger はべき剰余などの複数ステップの操作のスピードを上げるために、package-private の可変「コンパニオンクラス」を持っている。

#### 解決策2: public の可変コンパニオンクラスを提供する

クライアントがどのような操作を行いたいか正確に予想できない場合、public の可変コンパニオンクラスを提供することでパフォーマンスを改善できる。

例えば、String クラスはその可変コンパニオンクラスである StringBuilder（と今は使われなくなった StringBuffer）を提供している。

### 不変クラスの設計

前述のとおり、不変性を保証するためにはサブクラス化を許してはならない。これはクラスを final にすることで実現できるが、代わりにそのクラスのコンストラクタを全て package-private または private として、public のファクトリメソッドを追加することでも実現できる（項目1）

```
public class Complex {
    private final double re;
    private final double im;

    private Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    }

    // 残りは変更なし
}
```

複数のパッケージプライベートの実装クラスを使うことができるため、この方法の方がより柔軟性がある。また、public あるいは protected のコンストラクタを持たないクラスを別のパッケージから拡張することは不可能であるため、このクラスは実質的に final であると言える。

さらに、この方法には static ファクトリメソッドのオブジェクトキャッシュ能力を後のリリースで改善することで、クラスのパフォーマンスをチューニングする余地もある。

##### BigInteger と BigDecimal は実質的に final でない

BigInteger と BigDecimal が書かれた当時、不変クラスは実質的に final でなければならないことが広く理解されていなかったため、メソッドは全てオーバーライド可能になってしまっている。残念ながら、後方互換性を保ちながらこれを修正することはできていない。

そのため、信頼できないクライアントから引数として受け取った BigInteger または BigDecimal が不変であることを期待するなら、その引数が「本物の」BigInteger か BigDecimal であるか検査しなければならない。もしそれが信頼できないサブクラスのインスタンスならば、それを防御的にコピーしなければならない（項目50）。

```
public static BigInteger safeInstance(BigInteger val) {
    return val.getClass() == BigInteger.class ? val : new BigInteger(val.toByteArray());
}
```

### final でないフィールドを許容する場合

この項目の最初で、不変クラスのどのメソッドもオブジェクトを変更しないし、全てのフィールドは final でなければならないと述べたが、これらの規則は必要以上に厳しい。つまり、外部に分からない変更であれば許容しても良い。

不変クラスによっては、コストが高く付く計算の結果をその計算が初めて要求されたときにキャッシュするための final でない冗長なフィールドを持っている。オブジェクトが不変であるため、計算が再び行われたとしても同じ結果になることが保証される。

例えば、PhoneNumber の hashCode メソッド（項目11、55ページ）は最初に呼び出されたときにハッシュコードを計算して、再び必要になったときのためにキャッシュしている。このような方法は遅延初期化（項目83）と呼ばれ、String クラスでも使われている。

### 不変クラスで Serializable を実装する際の注意事項

もし不変クラスが Seriarizable を実装していて、そのクラスが可変オブジェクトを参照しているフィールドを持っていたら、たとえデフォルトのシリアライズ形式が受け入れられるものであっても、明示的に readObject メソッドか readResolve メソッドを提供するか、ObjectOutputStream.writeUnshared メソッドと ObjectInputStream.readUnshared メソッドを使わなければならない。そうしなければ攻撃者はクラスの可変インスタンスを生成できる。これについては項目88で詳細に説明する。

### まとめ

- 可変にすべき正当な理由がない限り、クラスは不変であるべき
- 特に小さな値オブジェクトは常に不変にすべき（java.util.Date や java.awt.Point などは不変とすべきだったが、不変になっていない）
- 

## 項目18 継承よりもコンポジションを選ぶ

継承が常に再利用のための最善の方法であるとは限らない。

以下のような場合には、継承を安全に使うことができる。

- サブクラスとスーパークラスの実装が同じプログラマの管理下にある場合
- 拡張のために設計されて、かつ拡張のために文書化されているクラスを拡張する場合（項目19）

一方、パッケージをまたがって普通の具象クラスから継承することは危険である。

### この項目の注意事項

この本では、（あるクラスが他のクラスを拡張した場合の）実装継承の意味で「継承」を使う。本項目で議論される問題は（クラスがインタフェースを実装した場合や、インタフェースが他のインタフェースを拡張した場合の）インタフェース継承には適用されない。

### 不適切な継承の例

#### オーバーライドするメソッドの実装に依存する場合

メソッド呼び出しと異なり、継承はカプセル化を破る。つまり、サブクラスはスーパークラスの実装の詳細に依存する。スーパークラスの実装はリリースごとに変更されるかもしれないし、もし変更されたらサブクラスはコードが一切変更されていなくても動かなくなるかもしれない。

例えば、HashSet が生成されてからいくつの要素が追加されたかを知るため、HashSet を継承して要素の挿入回数を記録するクラスを作るとする。HashSet クラスは要素を追加するために add と addAll の2つのメソッドを持っているので、それぞれを次のようにオーバーライドする。

```
// 継承の不適切な利用の例
public class InstrumentedHashSet<E> extends HashSet<E> {
    // 要素が挿入された回数
    private int addCount = 0;

    public InstrumentedHashSet() {}

    public InstrumentedHashSet(int intCap, float loadFactor) {
        super(initCap, loadFactor);
    }

    @Override public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}
```

このクラスは妥当に見えるが、正しく動作しない。

```
InstrumentedHashSet<String> s = new InstrumentedHashSet<>();
s.addAll(List.of("Snap", "Crackle", "Pop"));
s.getAddCount(); // 6
```

これは、HashSet の addAll メソッドが内部で add メソッドを使っているためである。このため、addAll メソッドを用いて追加された要素が重複してカウントされてしまった。

addAll メソッドのオーバーライドをやめることでこのサブクラスを一時的に修理することはできるが、これは HashSet の addAll メソッドが add メソッドを使って実装されているという事実に依存してしまっている。これは Java プラットフォームの全ての実装で行われる保証はないし、リリースごとに変更される可能性もあるため、InstrumentedHashSet クラスは脆弱になってしまう。

上の方法に比べると、指定されたコレクションをイテレートして、個々の要素に対して add メソッドを呼び出すように addAll メソッドをオーバーライドする方法の方が多少マシである。ただしこれは、自己利用しているかわからないスーパークラスのメソッドを再実装しているため、実装が困難で誤りやすく、パフォーマンスの低下を引き起こすかもしれない。さらに、メソッドによってはサブクラスがアクセスできない private フィールドへのアクセスなしでは実装できない場合があるため、この方法が常に可能だとは限らない。

```
public class InstrumentedHashSet<E> extends HashSet<E> {
    // 省略
    
    @Override public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override public boolean addAll(Collection<? extends E> c) {
        for(E e: c) {
            this.add(e);
        }
    }

    // 省略
}
```

#### 将来のリリースで追加されるメソッドによって不正な値が入ってしまう可能性

仮に要素の追加を行う全てのメソッドをオーバーライドしてうまく動作するようになったとしても、将来のリリースで要素を追加するためのメソッドが新たに追加された場合、サブクラスのインスタンスに不正な要素を追加できるようになってしまう。実際に Hashtable と Vector をコレクションフレームワークのいち員とするために修正した際、同様のセキュリティホールを塞がなければならなかった。

#### 将来のリリースで追加されるメソッドと名前が衝突する可能性

上記の問題はいずれもメソッドをオーバーライドしたことで起こっているが、メソッドをオーバーライドせず単にメソッドを追加した場合でも問題が起こる可能性がある。

もし、後のリリースでスーパークラスに新たなメソッドが追加され、サブクラスにも同じシグニチャで異なる戻り値型のメソッドを定義していたら、サブクラスはコンパイルできなくなる。また、サブクラスに同じシグニチャで同じ戻り値型のメソッドをていぎしていたら、スーパークラスのメソッドをオーバーライドしていまい前述のような問題を引き起こす。さらに、サブクラスのメソッドが書かれた時点でスーパークラスの新たなメソッドの契約は書かれていないので、その契約を満たすかは疑わしい。

### コンポジションを使う

既存のクラスを拡張する代わりに、新たなクラスに既存クラスのインスタンスを参照する private フィールドを持たせることで、前述の問題を全て避けることができる。これをコンポジションという。

新たなクラスの各インスタンスメソッドは、保持している既存クラスのインスタンスに対して対応するメソッドを呼び出して、その結果を返す。これを転送と言い、これを行うメソッドを転送メソッドと言う。

転送は既存クラスの実装の詳細に依存しない上、既存クラスに新たなメソッドが追加されたとしても影響がない。

InstrumentedHashSet をコンポジション/転送を使って書き換えると次のようになる。

```
// ラッパークラス - 継承の代わりにコンポジションを使っている
public class InstrumentedSet<E> extends ForwardingSet<E> {
    private int addCount = 0;

    public InstrumentedSet(Set<E> s) {
        super(s);
    }

    @Override public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}

// 再利用可能な転送クラス
public class ForwardingSet<E> implements Set<E> {
    private final Set<E> s;
    public ForwardingSet(Set<E> s) { this.s = s; }

    public void clear() { s.clear(); }
    public boolean contains(Object o) { return s.contains(o); }
    public boolean isEmpty() { return s.isEmpty(); }
    public int size() { return s.size(); }
    public Iterator<E> iterator() { return s.iterator(); }
    public boolean add(E e) { return s.add(e); }
    public boolean remove(Object o) { return s.remove(o); }
    public boolean containsAll(Collection<?> c) { return s.containsAll(c); }
    public boolean addAll(Collection<? extends E> c) { return s.addAll(c); }
    public boolean removeAll(Collection<? extends E> c) { return s.removeAll(c); }
    public boolean retainAll(Collection<? extends E> c) { return s.retainAll(c); }
    public Object[] toArray() { return s.toArray(); }
    public <T> T[] toArray(T[] a) { return s.toArray(a); }
    @Override public boolean equals(Object o) { return s.equals(o); }
    @Override public int hashCode() { return s.hashCode(); }
    @Override public String toString() { return s.toString(); }
}
```

InstrumentedSet クラスの設計は、HashSet クラスの機能を表す Set インタフェースが存在するため可能となっている。

コンポジション/転送を用いた InstrumentedSet クラスは頑強であると共に柔軟性を持っている。継承を用いた方法では、スーパークラスで提供されるコンストラクタごとに別々のコンストラクタを必要とするが、この方法では一つのコンストラクタがあらゆる Set 型を受け取り、計測機能を持った Set 型に変換するため、既存のどのコンストラクタに対してもうまく対応できる。また、このラッパークラスは HashSet を含むどの Set の実装を計測するためにも使用することができる。

```
// 様々な Set の実装に対応している例
Set<Instant> times = new InstrumentedSet<>(new TreeSet<>(cmp));
Set<E> s = new InstrumentedSet<>(new HashSet<>(INIT_CAPACITY));
```

次のように、コンポジション/転送を用いた InstrumentedSet クラスは、計測なしで既に使われている Set インスタンスを一時的に計測するのにも使える。

```
static void walk(Set<Dog> dogs) {
    InstrumentedSet<Dog> iDogs = new InstrumentedSet<>(dogs);
    // このメソッド内では、dogs の代わりに iDogs を使う
}
```

個々の InstrumentedSet インスタンスは他の Set インスタンスを包むため、InstrumentedSet クラスはラッパークラスとも呼ばれる。また、InstrumentedSet クラスが計測機能を追加することで Set を装飾（decorate）するので、Decorator パターンとも呼ばれる。

コンポジションと転送の組み合わせが「委譲」と呼ばれることがあるが、技術的にはラッパーオブジェクトがラップしているオブジェクトへ自分自身を渡さない限り委譲ではない。

### ラッパークラスの注意点

ラッパークラスの欠点はほとんど無い。

注意事項としてラッパークラスは、オブジェクトが自分自身を後で他のオブジェクトに渡し、後で呼び出してもらう、コールバックフレームワークで使うのには向いていない。これは、ラップされたオブジェクトがラッパーを知らないため自分自身の参照を渡してしまい、コールバックがラッパーを避けてしまうことで起こる。これを SELF 問題と言う。

メソッド呼び出しの転送によるパフォーマンス低下やラッパーオブジェクトによるメモリ量への影響を懸念する声もあるが、実際にはいずれも大きな問題にはならない。

転送メソッドを書くのは少し面倒だが、個々のインタフェースに対して一度だけ再利用可能な転送クラスを書くだけ良い。さらに、転送クラスが公式に提供されている場合もある。例えば、Guava は全てのコレクションインタフェースに対する転送クラスを提供している。

### 継承を使うべきとき

サブクラスがスーパークラスのサブタイプである場合にだけ、継承を使うべきである。つまり、クラス B とクラス A との間に「is-a」関係が成り立つ場合にだけ、クラス A を拡張すべきである。

「すべての B は A であるか？」という問いに「はい」と答えられないならば、B は A を拡張すべきでない。この場合は大抵、B が A のインスタンスを private として保持して、異なる API を外部に公開すべきである。そうすると、A は B の一部分ではなく、B の実装の詳細にすぎない。

Java プラットフォームライブラリには、この原則を破っているものが多くある。

- スタックはベクターでないので、Stack は Vector を拡張すべきでない
- プロパティリストはハッシュテーブルではないので、Properties は Hashtable を拡張すべきでない

これらはいずれもコンポジションにするのが適切だっただろう。

### コンポジションを使うべきときに継承を使う弊害

コンポジションが適切な場合に継承を使うと、不必要に実装の詳細を外部に公開してしまう。その結果、API は継承元のクラスの実装に縛られ、クラスのパフォーマンスを永久に制限してしまう。

#### 公開すべきでないスーパークラスのメソッドを公開してしまう

内部を公開することでクライアントが直接内部にアクセスすることを許してしまい、クライアントを惑わせるようなセマンティクスになってしまう。

例えば、p.Properties インスタンスを参照していたとしたら、p.getProperty(key) は p.get(key) と異なる結果をもたらすかもしれない。p.getProperty(key) はデフォルト値を考慮するが、Hashtable から継承された p.get(key) はデフォルト値を考慮しない。

##### 補足: Properties クラスって何？ kintone チームでは……

Properties クラス … properties ファイル (kintone でいうと application.properties とか) を読むためのクラス。

p.getProperty(key) が考慮するデフォルト値というのは、例えば、`application_ja.properties` に指定されたキーが無かったら `application.properties` を参照するというようなもの。

#### スーパークラスを直接変更することでサブクラスの不変式が破壊されてしまう

スーパークラスを直接変更することでサブクラスの不変式をクライアントが破壊できてしまう場合は、さらに深刻である。

例えば、Properties は文字列だけがキー及び値として許されるべきだと意図して作られたが、スーパークラスである HashTable に直接アクセスすることでその普遍式が破られてしまう。一旦、この不変式が破られると、Properties API の他の部分（load と store）を使うことはできなくなる。

### 継承を使う前に、スーパークラスに欠陥が無いか考える

もし、拡張しようとしているクラスに欠陥があれば、自分のクラスにもその欠陥を伝播させてしまう。継承はスーパークラスの API のあらゆる欠陥も伝播させるが、コンポジションはそのような欠陥を隠蔽する新たな API を設計することができる。

## 項目19 継承のために設計および文書化する、でなければ継承を禁止する

項目18では、設計及び文書化されていないクラスを継承することの危険性について述べた。この項目では、継承のためにクラスを設計及び文書化するにはどうすれば良いかということについて述べる。

### オーバーライド可能なメソッドの自己利用を文書化する

クラスはメソッドをオーバーライドする際の影響を明確にするため、オーバーライド可能なメソッドの自己利用について文書化しなければならない。

各メソッドが個々のオーバーライド可能なメソッドをどのような順番で呼び出し、各呼び出しが後の処理にどのように影響するかがドキュメントに書かれている必要がある。ここでいうオーバーライド可能なメソッドとは、final でない public か protected のメソッドのことである。呼び出しがバックグラウンドのスレッドや static 初期化子から行われる場合にも漏れなく記載する。

慣習的に、オーバーライド可能なメソッドを呼び出すメソッドは、Javadoc の `@implSpec` タグにオーバーライド可能なメソッドの呼び出しに関する内部の動きを記述する。このタグに書かれた内容は「実装要件」というセクションに表示される。

以下は、java.util.AbstractCollection の仕様である。

> public boolean remove(Object o)
>
> 指定された要素のインスタンスを、その要素が存在していれば、このコレクションから一つ取り除きます（オプションの操作）。正式にはコレクションが、Object.equals(o, e) が true である要素 e を一つ以上保持していれば、一つ要素を取り除きます。コレクションが指定された要素を保持していたら（あるいは、同じことですが、コレクションが呼び出しの結果変化したら）、true を返します。
>
> 実装要件: この実装は、指定された要素を探すのにコレクションをイテレートします。もし、その要素が見つかれば、イテレータの remove メソッドを使って、コレクションからその要素を取り除きます。本コレクションの iterator メソッドから返されたイテレータが remove メソッドを実装していなければ、この実装は UnsupportedOperationException をスローし、本コレクションは指定されたオブジェクトを保持したままであることに注意してください。

このドキュメントでは以下の点が明確になっている。

- iterator メソッドをオーバーライドすることで、remove めそっどの振る舞いに影響を与えること
- iterator メソッドから返された Iterator の振る舞いが、どのように remove メソッドの振る舞いに影響を与えるか

これは、項目18で HashSet をサブクラス化した際に、add メソッドのオーバーライドによって addAll メソッドの振る舞いに影響を与えるかどうかを単純に判断できなかったのと対象的である。

しかし、これは「良い API ドキュメントは、メソッドが**何を**するのかを記述し、**どのように**行うかは記述すべきでない」という格言を破ってしまっている。継承がカプセル化を破っているため、本来サブクラス化されなければ示すべきではない実装の詳細を文書化せざるを得ない。

#### @implSpec の注意点

`@implSpec` タグは Java 8 で追加されて、Java 9 では広く使われている。このタグはデフォルトで有効であるべきだが、Java 9 の時点で Javadoc ユーティリティはコマンドラインオプション `-tag "implSpec:a:実装要件:"` を渡されない限り、このタグを無視する。

### 継承のために用意するメソッド

プログラマが効率的にサブクラスを書けるようにするために、スーパークラスは protected のメソッドを賢く選択し、そのメソッドを通してクラス内部の動作へのフックを提供しなければならないかもしれない。あるいは、稀に protected のフィールドを提供しなければならないかもしれない。

例えば、java.util.AbstractList の removeRange メソッドについて考える。

>protected void removeRange(int fromIndex, int toIndex)
>
>要素のインデックスが fromIndex を含んで、toIndex を含まない範囲にあるすべての要素を、このリストから取り除きます。後の要素を左へシフトします（後の要素のインデックスを減らします）。この呼び出しは、AbstractList を（toIndex - fromIndex）要素分短くします。（もし、toIndex==fromIndexならば、この操作は何もしません。）
>
>このメソッドは、このリストとそのサブリストに対する clear 操作により呼び出されます。リスト実装の内部を利用するためにこのメソッドをオーバーライドすることで、このリストとそのサブリストに対する clear 操作のパフォーマンスを大幅に改善できます。
>
>実装要件: この実装は fromIndex の前の位置のリストイテレータを取得して、範囲全体が取り除かれるまで ListIterator.next とその後の ListIterator.remove の呼び出しを繰り返します。注意: もし、ListIterator.remove が一次の時間を要するならば、この実装は二次の時間を要します。
>
>パラメータ:  
>　fromIndex: 取り除かれる最初の要素のインデックス。  
>　toIndex: 取り除かれる最後の要素の次のインデックス。

このメソッドは、List の実装の最終的なユーザには関係ないものだが、サブクラスが速い clear メソッドを容易に提供できるようにするためだけに用意されている。removeRange メソッドが無ければ、サブリストに対して clear メソッドが呼ばれると、サブクラスは二次の時間に対処するか、最初から subList の仕組みを書き直さなければならなくなるだろう。

継承のためのクラスを設計するために protected のメンバーが何を公開すべきかを決める有効な指針は無い。真剣に熟考し、よく推測し、複数のサブクラスを書いてテストするのが最善の方法である。

protected のメソッドやフィールドが多いほど実装の詳細に対する束縛が増えるため、その数はできるだけ減らすべきである。ただし、あまりに少なすぎると実用的に再利用しづらくなるため、少なくなりすぎてもいけない。

### 継承するために設計されたクラスをテストする

継承するために設計されたクラスをテストする唯一の方法は、サブクラスを書くことである。これにより、protected のメンバーが過不足無く書かれているかどうか確かめることができる。

経験的に、継承するために設計されたクラスをテストするには、3つのサブクラスを実装すれば良い。そのうち、一つか二つはスーパークラスの作成者以外の人に書いてもらうべきである。

広く使われそうなクラスを継承されるように設計する場合、文書化した自己利用の方法と、protected のメンバーによって暗黙に表される実装上の決定事項に、永久に束縛される。この束縛は、後のリリースでパフォーマンスや機能の改善を困難にしたり不可能にしたりするため、リリース前にサブクラスを書くことでクラスをテストしなければならない。

### 継承のための情報を含むドキュメントの問題点

継承に関する特別なドキュメントは、クラスのインスタンスを生成してメソッドを呼び出すプログラマ向けに設計されている通常のドキュメントを散らかしてしまう。この本の執筆時点では、サブクラスを実装するプログラマだけが興味を持つ情報と、通常の API ドキュメントを分離するためのツールはほとんど無い。

### 継承のためのクラスのコンストラクタは、オーバーライド可能なメソッドを呼び出してはならない

継承を可能にするためにクラスが従わなければならない制約がいくつかある。

直接的にも間接的にも、コンストラクタはオーバーライド可能なメソッドを呼び出してはならない。

スーパークラスのコンストラクタはサブクラスのコンストラクタよりも前に実行されるため、サブクラスでオーバーライドしているメソッドはサブクラスのコンストラクタが実行される前に呼び出される。もし、オーバーライドしているメソッドがコンストラクタで行われる初期化に依存している場合、そのメソッドは期待通りに動作しないだろう。

例えば、以下のようなクラスを考える。
　
```
public class Super {
    // 不完全 - コンストラクタがオーバーライド可能なメソッドを呼び出している
    public Super() {
        overrideMe();
    }

    public void overrideMe() {
    }
}

public final class Sub extends Super {
    private final Instant instant;

    Sub() {
        instant = Instant.now();
    }

    // スーパークラスのコンストラクタから呼び出される、オーバーライドしているメソッド
    @Override public void overrideMe() {
        System.out.println(instant);
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```

このプログラムがインスタントを二度表示することを期待するかもしれないが、コンストラクタ Sub が instant フィールドを初期化する前に、overrideMe メソッドがコンストラクタ Super に呼び出されるため、最初は null が表示される。このプログラムでは、final のフィールドが2つの状態を持って現れていることに注意する必要がある。

もし、overrideMe が instant の何らかのメソッドを呼び出したら、NullPointerException がスローされる。なお、上記プログラムが今のところ NullPointerException をスローしないのは、println メソッドが null 引数を許容するためである。

private、final、static のメソッドはオーバーライドできないため、コンストラクタから呼び出しても安全である。

### Cloneable インタフェースと Serializable インタフェースの注意点

継承のために設計する場合、Cloneable インタフェースと Serializable インタフェースは特殊な問題をもたらす。これらのインタフェースを実装することは、そのクラスを拡張するプログラマの負担を増やすことに繋がるため、継承のために設計されているクラスがどちらかのインタフェースを実装することは一般的に良い考えではない。

この2つのインタフェースを実装するための特別な対処法については、項目13と項目86で説明している。

#### 実装する場合の制限事項1: clone メソッドと readObject メソッドをコンストラクタから呼び出してはならない

継承のために設計されているクラスで Cloneable か Serializable を実装する場合、clone メソッドと readObject メソッドはコンストラクタと似た振る舞いをするので、その中でも同様にオーバーライド可能なメソッドを直接的にも間接的にも呼び出してはならない。

##### readObject メソッド

サブクラスの状態がデシリアライズされる前に、オーバーライドしているメソッドが実行され、失敗する。

##### clone メソッド

サブクラスの clone メソッドが複製先の状態を変更する前にオーバーライドしているメソッドが実行され、失敗する。

この失敗は複製先だけでなく、複製元のオブジェクトに対しても影響を及ぼす可能性がある。例えば、オーバーライドしているメソッドが複製先のオブジェクトをディープコピーしていると想定しているにもかかわらず、そのコピーがまだおこなわれていないような場合に問題が起こる。

#### 実装する場合の制限事項2: readResolve メソッドと writeReplace メソッドを protected にする

継承のために設計されたクラスで Serializable を実装する場合、そのクラスが readResolve メソッドか writeReplace メソッドを持っているならば、これらを private ではなく protected にしなければならない。

これらのメソッドが private ならば、サブクラスから黙って無視されてしまう。

### 改めて、継承のためのクラスを設計するかどうか検討する

ここまで述べたように、継承のためにクラスを設計することで、そのクラスにかなりの制限を課すことは明らかである。継承のためのクラスを設計するかどうかは軽く考えて決めるべきことではない。

#### 明らかに、継承のためのクラスを設計すべき場合

インタフェースの骨格実装（skeletal implementation）を含む抽象クラス（項目20）など

#### 明らかに、継承のためのクラスを設計すべきでない場合

不変クラス（項目17）など

#### 悩ましい場合（やらない方が良い場合）

通常の具象クラスは伝統的に final でもないし、継承のための設計や文書化がされていないため、これを継承するのは危険である。このようなクラスに変更が行われるたびに、そのクラスを拡張しているサブクラスが正しく機能しなくなる可能性がある。これは単なる理論的な問題ではなく、よく起こる問題である。

### 継承を禁止する

通常の具象クラスが継承されることで先述のような問題が起こることを防ぐための最も良い解決策は、安全にサブクラス化されるための設計も文書かもされていないクラスの継承を禁止することである。

継承を禁止する方法は、以下の2つである。

- クラスを final と宣言する（こちらの方が簡単）
- 全てのコンストラクタを private か package-private にして、コンストラクタの代わりに public の static ファクトリメソッドを提供する

2つ目の方法については、内部的にサブクラスを使う柔軟性があることを項目17で述べた。

多くのプログラマは計測、通知、同期などの機能を追加したり、機能を制限するために、通常の具象クラスをサブクラス化することに慣れているので、このアドバイスを受け入れがたいと感じるかもしれない。しかし、クラスが Set、List、Map などのようなクラスの本質を表すインタフェースを実装していれば、サブクラス化を禁止することにためらいを感じることは無いだろう。また、項目18で説明したラッパークラスパターンは、機能を増やすという点において継承よりも優れている。

### それでも具象クラスを継承したい場合

具象クラスが標準のインタフェースを実装していなければ、継承を禁止することはプログラマにとって不都合かもしれない。そのようなクラスを継承することを許さなければならないならば、そのクラスがオーバーライド可能なメソッドを呼び出さないようにし、それを文書化するべきである。これにより、メソッドをオーバーライドすることで他のメソッドの振る舞いに影響を与えることがなくなるため、安全にサブクラス化できるクラスを作成することができる。

以下の手順で、クラスの振る舞いを変えることなく、オーバーライド可能なメソッドの自己利用を機械的に取り除くことができる。

1. 個々のオーバーライド可能なメソッドの本体を private の「ヘルパーメソッド」へ移動する
2. オーバーライド可能なメソッドから、そのヘルパーメソッドを呼び出すように変更する
3. オーバーライド可能なメソッドの自己利用を、オーバーライド可能なメソッドに対応するヘルパーメソッドの直接呼び出しに置き換える

```
// ダメな例
public class MySet<E> {
    // 省略

    public add(E e) {
        // 要素を追加する処理
    }

    public addAll(Collections<? extends E> c) {
        for (E e: c) {
            add(e);
        }
    }
}
```

```
// オーバーライド可能なメソッドの自己利用を取り除いた例
public class MySet<E> {
    // 省略

    public add(E e) {
        this.addInternal(e);
    }

    private addInternal(E e) {
        // 要素を追加する処理
    }

    public addAll(Collections<? extends E> c) {
        for (E e: c) {
            addInternal(e);
        }
    }
}
```

## 項目20 抽象クラスよりもインタフェースを選ぶ

Java は複数の実装を許す型を定義するためにインタフェースと抽象クラスの二つの仕組みを提供している。

Java 8 でインタフェースに default メソッドが導入されたため、両方の仕組みでインスタンスメソッドの実装を提供できる。

主な違いは、抽象クラスで定義された型を実装するには、クラスがその抽象クラスのサブクラスでなければならないということである。Java は単一継承のみを許しているため、抽象クラスに対するこの制約は型定義として抽象クラスを使うことを著しく妨げている。インタフェースの場合、要求されるメソッドを定義して一般契約に従っているクラスであれば、クラス階層のどこに位置していてもインタフェースを実装することが許されている。

### 新たなインタフェースを実装するように既存のクラスを変更する

新たなインタフェースを実装するように既存のクラスを変更するために必要な手順は以下の2つだけである。

- 必要なメソッドがまだ存在しなければ、追加する
- クラス宣言に implements 節を追加する

一方、一般に既存のクラスを新たな抽象クラスを拡張するように変更することはできない。二つのクラスに同じ抽象クラスを拡張させたければ、その抽象クラスが両方のクラスの先祖のサブクラスとなるよう、型階層の中の高い位置に置かなければならない。これによって、新たな抽象クラスのすべての子孫がそのサブクラスとして適切かどうかに関係なくサブクラスであることを余儀なくされ、型階層に大きな影響を与える。

### インタフェースを使って、ミックスインを定義する

#### ミックスイン（mixin）とは？

（大雑把に言うと、）クラスが「本来の型」に加えて、何らかの任意の振る舞いを提供していることを宣言するためにクラスが実装できる型のこと。型本来の機能に対して任意の機能を「混ぜ合わせる（mix in）」ことを可能にしているため、こう呼ばれる。

例えば、Comparable は他の相互比較可能なオブジェクトに対してクラスのインスタンスが順序化されていると宣言できるようにするミックスインである。抽象クラスを既存クラスへ組み込めないのと同様に、クラスは二つ以上の親を持てないし、ミックスインを入れるべき妥当な場所がクラス階層に無いため、ミックスインを定義するために抽象クラスを使うことはできない。

インタフェースは、階層を持たない型フレームワークの構築を可能にしている。

例えば、歌手を表すインタフェースと楽曲制作者を表すインタフェースがあると仮定する。

```
public interface Singer {
    AudioClip sing(Song s);
}

public interface Songwriter {
    Song compose(int chartPosition);
}
```

実世界では、歌手の中に楽曲制作者もいる（シンガーソングライター）。Singer と Songwriter の2つを定義するためにインタフェースを使ったため、1つのクラスがその両方を実装するのに何の問題もない。Singer と Songwriter の両方を拡張し、その兼務に適切な新たなメソッドを追加したインタフェースを次のように定義できる。

```
public interface SingerSongwriter extends Singer, Songwriter {
    AudioClip strum();
    void actSensitive();
}
```

このような柔軟性は必ずしも必要ではないが、必要な場合にはインタフェースを使うことで問題を回避できる。

もし、抽象クラスで同様のことを行おうとすると、サポートされている属性の組み合わせごとに別々のクラスを含むこととなり、クラス階層が膨れ上がる。もし、型システムに n 個の属性があったとしたら、サポートしなければならない可能性のある組み合わせは 2^n 通りになる（組み合わせ爆発）。膨れ上がったクラス階層の中には共通の振る舞いを表す型がないので、引数の型だけが異なる多くのメソッドを持つような膨れ上がったクラスを生み出してしまう。

型を定義するのに抽象クラスを使うと、機能を追加したいプログラマに継承以外の選択肢を与えないが、インタフェースはラッパークラスイディオム（項目18）を通して、安全で強力な機能強化を可能にする。継承によって作られたクラスは、ラッパークラスよりも劣る上、脆い。

### デフォルトメソッドで実装補助を提供する

インタフェースのメソッドに、他のインタフェースメソッドを用いる明らかな実装が存在する場合、デフォルトメソッド形式で実装補助を提供することを検討する。デフォルトメソッドの例は、106ページの `removeIf` メソッドを参照。デフォルトメソッドを提供する場合、Javadoc の `@implSpec` タグ（項目19）を使って継承のためにデフォルトメソッドを文書化するべきである。

デフォルトメソッドで提供できる実装補助には、以下のような制限がある。

- Object のメソッドである equals と hashCode に対するデフォルトメソッドの提供は許されていない。
- インタフェースがインスタンスフィールドや（private staic メソッドを除く）public でない static のメンバーを含むことは許されていない。
- 管理が及ばないインタフェースにデフォルトメソッドを追加することはできない。

### 骨格実装

#### 抽象骨格実装

インタフェースに付随する抽象骨格実装クラスを提供することで、インタフェースと抽象クラスの長所を組み合わせられる。

インタフェースは型を定義し、何らかのデフォルトメソッドを提供する。その上で骨格実装は、インタフェースの基本のメソッドに基づいて、残りの基本ではないメソッドを実装する。これは Template Method パターンである。

慣習として、骨格実装クラスは Abstract<インタフェース名> と命名される。  
例えば、コレクションフレームワークは主要なコレクションインタフェースごとに付随する骨格実装を提供しているが、それらは `AbstractCollection`、`AbstractSet`、`AbstractList`、`AbstractMap` と命名されている。

※ SkeletalCollection、SkeletalSet、SkeletalList、SkeletalMap と呼ぶのが妥当であったかもしれないが、今では Abstract〜 と命名する慣習が確立してしまっている。

#### 骨格実装の使用例

適切に骨格実装が設計されている場合、それはプログラマがインタフェース独自の実装を行うことを簡単にする。

例えば、List の骨格実装 AbstractList を使って int 配列を Integer インスタンスとして見せるようなアダプターを実装すると、次のようになる。  
これは完全に機能する List の実装を含む static ファクトリメソッドであるが、List に実装されるべき全てのことを考慮すると、この例から骨格実装がいかにインターフェスの実装を簡単にしているかを読み取れる。

```
// 骨格実装上に構成された具象実装
static List<Integer> intArrayAsList(int[] a) {
    Objects.requireNonNull(a);

    // Java 9 以降では、ここでのダイアモンド演算子は有効。
    // それより前のバージョンでは、<Integer> を指定する。
    return new AbstractList<>() {
        @Override public Integer get(int i) {
            return a[i]; // 自動ボクシング（項目6）
        }

        @Override public Integer set(int i, Integer val) {
            int oldVal = a[i];
            a[i] = val;
            return oldVal;
        }

        @Override public int size() {
            return a.length;
        }
    };
}
```

#### 骨格実装のメリット

骨格実装の優れた点は、抽象クラスが型定義の役割を果たす際の深刻な制約を課すことなく、実装補助を提供できることである。

インタフェースを実装する人のほとんどは骨格実装を拡張するだろうが、それを選択することはあくまでも任意である。  
つまり、もし既存のクラスが骨格実装を拡張できないならば、そのクラスは自分でインタフェースを実装することができる。この場合でも、クラスはインタフェース自身で提供されているデフォルトメソッドの恩恵を得ることができる。  
さらにこのクラスは、骨格実装を拡張した private の内部クラスのインタンスを保持しておくことで、インタフェースの呼び出しをそのインスタンスに転送することができる。これを擬似多重継承という。

疑似多重継承は、項目18で述べたラッパークラスイディオムに関連した技法で、落とし穴を避けながら多重継承のほとんどの利点を提供している。

#### 骨格実装を書く

まず、インタフェースを調べて、他のメソッドを実装できる（？）基本操作がどのメソッドであるかを決める。これは、骨格実装において抽象メソッドになる。  
次に、基本操作で直接実装できるメソッド全てに対してインタフェース内でデフォルトメソッドを提供する。先述のとおり、このとき equats や hashCode といった Object のメソッドにはデフォルトメソッドを提供できない。

もし基本操作メソッドとデフォルトメソッドでインタフェースを網羅したなら、骨格実装クラスは必要ない。  
網羅できなかった場合には、インタフェースを実装すると宣言したクラスを書いて、残りのインタフェースやメソッドを全て実装する。このとき、そのクラスは処理に適切な public ではないフィールドやメソッドを含んでいても構わない。

#### 骨格実装の例

骨格実装の例として、Map.Entry インタフェースを考える。

基本操作は以下の3つである。

- getKey
- getValue
- setValue(任意)

Map.Entry インタフェースは equals と hashCode の振る舞いを定義している。また、基本操作を使った toString の実装は明らかである。

Object のメソッドのオーバーライドはデフォルトメソッドには許されていないため、この骨格実装は Map.Entry インタフェース内に実装したり、サブインタフェースとして実装したりはできない。

```
// 骨格実装クラス
public abstract class AbstractMapEntry<K,V> implements Map.Entry<K,V> {
    // 変更可能なマップでのエントリは、このメソッドをオーバーライドしなければならない
    @Override public V setValue(V value) {
        throw new UnsupportedOperationException();
    }

    // Map.Entry.equals の一般契約を実装
    @Override public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry<?,?> e = (Map.Entry) o;
        return Objects.equals(e.getKey(), getKey())
            && Objects.equals(e.getValue(), getValue());
    }

    // Map.Entry.hashCode の一般契約を実装
    @Override public int hashCode() {
        return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
    }

    @Override public String toString() {
        return getKey() + "=" + getValue();
    }
}
```

#### 骨格実装のドキュメンテーション

簡潔にするために上記の例ではドキュメンテーションコメントを省略しているが、骨格実装は継承されるために設計されているため、項目19で述べた設計とドキュメンテーションの指針に全て従うべきである。

インタフェースのデフォルトメソッドで構成されるか、抽象クラスであるかに関わらず、骨格実装には良いドキュメンテーションが必要である。

### まとめ

- インタフェースは複数の実装を許す型を定義するための最善の方法である。
- インタフェースを設計する際には、骨格実装を提供することを検討すべきである。
- 可能であれば、インタフェースのデフォルトメソッドとして骨格実装を提供すべきだが、インタフェースの制約によってそれが困難な場合には抽象骨格実装クラスを使う。

## 項目21 将来のためにインタフェースを設計する

Java 8 より前では、インタフェースに新たなメソッドを追加すると既存の実装は一般にそのメソッドを持っていないため、コンパイルエラーになってしまう。　　
Java 8 でデフォルトメソッド構文が追加されたことにより、コンパイルエラーを起こすことなく既存のインタフェースへメソッドを追加することができるようになった。

しかし、既存のインタフェースへ新たなメソッドを追加することにはリスクが伴う。

### インタフェースへ新たなメソッドを追加するリスク

Java へデフォルトメソッドが追加されたことにより、既存のインタフェースへのメソッド追加が可能となったが、以前から存在している全ての実装でデフォルトメソッドが動作する保証はない。  
デフォルトメソッドは既存の実装の知識を持っていないため、それらが合致しているかを知ることなく既存の実装に「注入」される。  
Java 8 より前まで、これらの実装はインタフェースが新たなメソッドを得ることはないという暗黙の理解の上で書かれていた。

主にラムダ（第7章）を活用するため、多くの新たなデフォルトメソッドが Java 8 の中核のコレクションインタフェースに追加された。  
Java ライブラリのデフォルトメソッドは高品質な汎用実装であり、ほとんどの場合うまく動作する。しかし、考えられる全ての実装の全ての不変式を維持するデフォルトメソッドを書くことが難しい場合もある。

### デフォルトメソッドが既存のクラスでうまく動作しない例

例えば、Java 8 で Collection インタフェースに追加された removeIf について考える。

このメソッドは与えられた boolean 関数が true を返す全ての要素を取り除く。  
デフォルト実装は、イテレータを使ってコレクションを走査し、個々の要素に対して boolean 関数（述語（predicate））を呼び出し、true を返した要素を取り除くためにイテレータの remove メソッドを使う。

```
// Java 8 で Collection インタフェースに追加されたデフォルトメソッド
default boolean removeIf(Predicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean result = false;
    for (Iterator<E> it = iterator(); it.hasNext()) {
        if (filter.test(it.next())) {
            it.remove();
            result = true;
        }
    }
    return result;
}
```

これは removeIf メソッドに対して書ける最善の汎用実装だが、実際の Collection の実装によってはうまく動作しない。

例えば、org.apache.commons.collections4.collection.SynchronizedCollection について考える。

Apache Commons ライブラリのこのクラスは、java.util の static ファクトリである Collections.synchronizedCollection が返すものと似ている。  
Apache の方は、コレクションの代わりにクライアントが提供するオブジェクトをロックに使う機構を追加で提供している。  
つまり、これはラッパークラス（項目18）であり、その全てのメソッドはラップしたコレクションへ委譲する前にロックオブジェクトに対して同期する。

Apache の SynchronizedCollection クラスは活発に保守されているが、この本の執筆時点で removeIf はオーバーライドされていない。  
このクラスが Java 8 と一緒に使われると、removeIf のデフォルト実装を継承し、個々のメソッド呼び出しが自動的に同期されるというこのクラスの約束を果たすことができない。  
デフォルト実装は同期について何も知らないし、ロックオブジェクトを保持しているフィールドへアクセスできない。

他のスレッドで並行してコレクションが修正されている状況でクライアントが SynchronizedCollection に対して removeIf メソッドを呼び出すと、ConcurrentModificationException がスローされるか、他の不明な振る舞いになるだろう。

Collections.synchronizedCollection から返されるパッケージプライベートのクラスなどの同様な Java プラットフォームライブラリの実装で同じ問題が発生しないよう、JDK の保守担当者たちはデフォルトの removeIf の実装とそれに似た他のメソッドをオーバーライドして、デフォルト実装を呼び出す前に必要な同期を行うように修正する必要があった。

以前から存在する Java プラットフォームの一部ではないコレクション実装は、インタフェースの変更と足並みをそろえて同様の変更を行う機会はなかったし、実装によってはまだ変更を行っていない。

デフォルトメソッドを含むインタフェースの実装をエラーや警告なしでコンパイルできたとしても、それは実行時に失敗するかもしれない。  
Java 8 でコレクションインタフェースに追加されたいくつかのメソッドはこの問題に陥りやすく、実際に既存の実装が影響を受けている例もある。

既存のインタフェースに新たなメソッドを追加するためにデフォルトメソッドを使うことは、その必要性が大きくない限り避けるべきである。  
また、必要性が大きい場合でも、デフォルトメソッドの実装によって既存のインタフェース実装が動作しなくなるかを時間をかけて真剣に検討すべきである。

デフォルトメソッドは、インタフェースからメソッドを削除したり既存のメソッドのシグニチャを変更したりするために設計されていない。　　
このようなインタフェースの変更を、既存のクライアントを壊すことなく行うのは不可能である。

### インタフェースをテストする

以上のことから、インタフェースの設計は注意深く行う必要がある。

インタフェースが不完全ならば、そのインタフェースを含む API をダメにしてしまうこともあるため、新たなインタフェースをリリースする前にはそのインタフェースをテストすることが重要である。

テストでは、複数のプログラマが異なる方法で、最低限3つ、異なる新たなインタフェースの実装を書くべきである。  
また、さまざまな処理を行うために新たなインタフェースのインスタンスを使う複数のクライアントプログラムを書くことも重要である。

これらのステップにより、インタフェースがリリースされるまえの修正が容易な時点で欠陥を見つけることができる。  
欠陥の種類によっては、インタフェースがリリースされた後に修正することも可能かもしれないが、それを期待すべきではない。

## 項目22 型を定義するためだけにインタフェースを定義する

クラスがインタフェースを実装する場合、インタフェースはそのクラスのインスタンスを参照するための型として機能する。  
つまり、クラスはインタフェースを実装することで、クライアントがそのインスタンスで何ができるのかを表現するべきである。

それ以外の目的のためにインタフェースを定義するのは不適切である。

### アンチパターン: 定数インタフェース

いわゆる定数インタフェースは、上述の目的に該当しないインタフェースである。

定数インタフェースはメソッドを持っておらず、定数を外部へ提供している static final フィールドだけから構成される。  
これらの定数を使うクラスは、クラス名で定数名を修飾する必要を避けるためにそのインタフェースを実装する。

```
// 定数インタフェースアンチパターン ※マネしないでね
public interface PhysicalConstants {
    // アボガドロ数 (1/mol)
    static final double AVOGADROS_NUMBER = 6.022_140_857e23;

    // ボルツマン定数 (J/K)
    static final double BOLZMANN_CONSTANT = 1.380_648_52e-23;

    // 電子の質量 (kg)
    static final double ELECTRON_MASS = 9.109_383_56e-31;
}
```

定数インタフェースパターンは、インタフェースの下手な使い方である。

クラスが何らかの定数を内部的に使うことは実装の詳細であるが、定数インタフェースを実装することでこれをクラスの公開 API に漏洩してしまう。  
よって、将来のリリースでクラスがその定数を必要としないように修正されたとしても、バイナリ互換性を保証するためにそのインタフェースを実装しなければならない。

もし、final ではないクラスが定数インタフェースを実装していると、そのサブクラスの全てがインタフェース内の定数によって名前空間を汚染される。

Java プラットフォームライブラリには、java.io.ObjectStreamConstants などの定数インタフェースがあるが、これらのインタフェースは変則的だとみなすべきであり、真似すべきではない。

### 定数を外部へ提供するには

定数を外部へ提供したい場合、その定数が既存のクラスやインタフェースに強く結びついているなら、そのクラスやインタフェースに定数をついかすべきである。  
例えば、Integer や Double などのボクシングされた数値基本データクラスのすべてが MIN_VALUE や MAX_VALUE を提供している。

もし、定数が列挙型のメンバーとしてみなされるのが最善ならば、enum 型（項目34）で定数を提供すべきである。  
そうでなければ、インスタンス化不可能なユーティリティクラス（項目4）で定数を提供すべきである。

次の例は、前述の PhysicalConstants のユーティリティクラス版である。

```
// 定数ユーティリティクラス
package com.effectivejava.science;

public class PhysicalConstants {
    private PhysicalConstants() {} // インスタンス化を防ぐ

    public static final double AVOGADROS_NUMBER = 6.022_140_857e23;
    public static final double BOLTZMANN_CONST  = 1.380_648_52e-23;
    public static final double ELECTRON_MASS    = 9.109_383_56e-31;
}
```

#### 補足: 数値リテラル内のアンダースコア

Java 7 以降では、数値リテラル無いにアンダースコアを使えるようになった。  
これは数値リテラルの値に何も影響せず、ただ数値リテラルを読みやすくするために使われる。

固定小数点数か浮動小数点数かに関わらず、5桁以上の数値リテラルでアンダースコアの追加を検討すると良い。  
整数あるいは浮動小数点数の10進数リテラルでは、3桁ごとにアンダースコアを入れるべきである。

### static インポートを使って定数の修飾をやめる

PhysicalConstants.AVOGADROS_NUMBER のように、ユーティリティクラスは一般的にクラス名で定数を修飾することをクライアントに要求する。

ユーティリティクラスが提供している定数を頻繁に使うなら、static インポート機構を使うことでこれを避けることができる。

```
// 定数の修飾を避けるために static インポートを使用する
import static com.effectivejava.science.PhysicalConstants.*;

public class Test {
    double atoms(double mols) {
        return AVOGADROS_NUMBER * mols;
    }
}
```

## 項目23 タグ付きクラスよりもクラス階層を選ぶ

### タグ付きクラスのデメリット

インスタンスが2つ以上の特性を持っていて、その特性を示すためのタグフィールドを持つクラスを目にすることがあるかもしれない。

例えば、円か長方形を表現できるクラスを考える。

```
// タグ付きクラス
// ※ クラス階層よりも劣る
class Figure {
    enum Shape { RECTANGLE, CIRCLE };

    // タグフィールド - この図の形
    final Shape shape;

    // shape が RECTANGLE である場合にだけ、これらのフィールドが使われる
    double length;
    double width;

    // shape が CIRCLE である場合にだけ、このフィールドが使われる
    double radius;

    // 円のコンストラクタ
    Figure(double radius) {
        shape = Shape.CIRCLE;
        this.radius = radius;
    }

    // 長方形のコンストラクタ
    Figure(double length, double width) {
        shape = Shape.RECTANGLE;
        this.length = length;
        this.width = width;
    }

    double area() {
        switch(shape) {
            case RECTANGLE:
                return length * width;
            case CIRCLE:
                return Math.PI * (radius * radius);
            default:
                throw new AssertionError(shape);
        }
    }
}
```

このようなタグ付きクラスは、以下のような多くの欠点を持っている。

- enum 宣言、タグフィールド、switch 文を使った決まりきったコードで散らかっている
- 複数の実装が単一クラスにごちゃごちゃに詰め込まれているため、読みやすさが損なわれている
- インスタンスが他の特性に属する関係のないフィールドを抱えているため、メモリ量が増加する
- コンストラクタが無関係のフィールドを初期化しない限りフィールドを final にできない
- コンストラクタはタグフィールドを設定して、コンパイラの助けなしに正しいデータフィールドを初期化しなければならない
  - 誤ったフィールドを初期化したら、実行時エラーになる
- ソースファイルを修正できなければ、タグ付きクラスに特性を追加できない
- 特性を追加したら、全ての switch 文に case を忘れず追加しなければならない
  - 忘れると、そのクラスは実行時エラーになる
- インスタンスのデータ型は特性に関する手がかりを提供していない

以上のことから、タグ付きクラスは冗長で誤りやすく非効率であると言える。

### クラス階層を使う

Java などのオブジェクト指向言語では、サブタイプ化を使用することで複数の特性のオブジェクトを表現できる単一のデータ型を定義することができる。  
タグ付きクラスはクラス階層の面白みのない模倣にすぎない。

#### 1. 抽象メソッドを含んだ抽象クラスを定義する

タグ付きクラスをクラス階層に変換するには、タグの値に依存した個々の操作に対する抽象メソッドを含んだ抽象クラスを定義する。  
この抽象クラスはクラス階層のルートである。

Figure クラスでは、そのような操作は area の一つしかない。

#### 2. タグの値に依存しないメソッドとデータフィールドをルートクラスに含める

抽象クラスには、タグの値に依存しない振る舞いを持つメソッドや全ての特性が使っているデータフィールドを入れる。

Figure クラスには、そのような特性に依存していない操作やデータフィールドはない。

#### 3. 具象サブクラスを定義する

タグ付きクラスで表現されていた個々の特性に対して、ルートクラスの具象サブクラスを定義する。

この例では、円と長方形のことである。

#### 4. 各特性に特有うのデータフィールドをサブクラスに含める

この例では、半径は円に特有、長さと幅は長方形に特有である。

#### 5. ルートクラスで定義された抽象メソッドの適切な実装を各サブクラスに含める

以上のような手順で Figure クラスを書き換えたクラス階層の例を示す。

```
// タグ付きクラスに対するクラス階層による置き換え
abstract class Figure {
    abstract double area();
}

class Circle extends Figure {
    final double radius;

    Circle(double radius) { this.radius = radius; }
    @Override double area() { return Math.PI * (radius * radius); }
}

class Rectangle extends Figure {
    final double length;
    final double width;

    Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }
    @Override double area() { return length * width; }
}
```

#### クラス階層のメリット

このクラス階層は、以下のとおり前述のタグ付きクラスの全ての欠点を克服している。

- 決まりきったコードは含まれておらず、コードは簡潔で明確である
- 獲得性の実装に対して独自のクラスが割り当てられており、これらは無関係なデータフィールドを持っていない
- 全てのフィールドが final である
- 以下のことがコンパイラが保証することで、switch 文に case を追加し忘れることによって実行時エラーが発生する可能性を無くす
  - 各クラスのコンストラクタがデータフィールドを初期化すること
  - ルートクラスで宣言された全ての抽象メソッドに対する実装を各クラスが持っていること
- 複数のプログラマがルートクラスのソースにアクセスせず、独立して相互に利用可能な方法でクラスを拡張できる
- 各特性に関連付けられた別々のデータ型が存在する
  - プログラマが変数の特性を指定し、特定の特性に関する変数と入力パラメータを制限できる

クラス階層のもう一つの長所は、型間の自然な階層を反映できて、柔軟性が増大し、コンパイル時に型検査が可能であることである。

もとの例のタグ付きクラスが正方形を含んでいたと仮定すると、（正方形も長方形も不変であれば）正方形が長方形の特殊な種類であることを反映するように次のようなクラス階層を作れる。

```
class Square extends Rectangle {
    Square(double side) {
        super(side, side);
    }
}
```

##### 補足: この例の注意事項

上記の階層中のフィールドはアクセッサーメソッドによってではなく、直接アクセスされていることに注意する。  
これは簡潔にするために行われているが、もしこのクラスが public だったら貧弱な設計となる。（項目16）

## 項目24 非 static のメンバークラスよりも static のメンバークラスを選ぶ

あるクラス内に定義されたクラスを「ネストしたクラス」という。  
ネストしたクラスは、そのエンクロージングクラスの中で使われるためだけに存在すべきである。

## 項目25 ソースファイルを単一のトップレベルのクラスに限定する